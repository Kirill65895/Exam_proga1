using System;

public sealed class Singleton
{
    // Статическая ленивая инициализация (потокобезопасна по умолчанию в .NET)
    private static readonly Lazy<Singleton> _instance = 
        new Lazy<Singleton>(() => new Singleton());

    // Публичное свойство для доступа к экземпляру
    public static Singleton Instance => _instance.Value;

    // Приватный конструктор (запрет создания через `new`)
    private Singleton()
    {
        Console.WriteLine("Singleton создан!");
    }

    // Пример метода
    public void DoWork()
    {
        Console.WriteLine("Работает Singleton!");
    }
}
class Program
{
    static void Main()
    {
        // Получаем экземпляр Singleton
        Singleton singleton = Singleton.Instance;
        singleton.DoWork();

        // Проверка, что это действительно один экземпляр
        Singleton anotherInstance = Singleton.Instance;
        Console.WriteLine($"Один и тот же экземпляр? {singleton == anotherInstance}"); // true
    }
}

Singleton (Одиночка) — один из самых известных порождающих паттернов проектирования. Он гарантирует, что существует только один экземпляр класса, и предоставляет глобальную точку доступа к этому экземпляру.

Тип паттерна Singleton относится к порождающим паттернам, так как он связан с процессом создания объектов и контролирует их количество.

Основная цель паттерна Singleton — обеспечить существование единственного экземпляра класса и предоставить глобальный доступ к этому экземпляру. Это особенно полезно в случаях, когда необходимо:
Контролировать доступ к ресурсам (например, базам данных).
Хранить глобальное состояние приложения.
Обеспечивать единую точку доступа к сервисам.

Метафоры из реального мира
Президент страны — в стране может быть только один действующий президент.

Потенциальные проблемы
При использовании Singleton могут возникнуть следующие проблемы:
Глобальное состояние — усложняет тестирование и поддержку кода.
Проблемы с многопоточностью — требуется дополнительная синхронизация.
Нарушение принципа единственной ответственности — класс может стать слишком универсальным.
