// Коллекция, которую будем перебирать
public class WordsCollection : IEnumerable
{
    private readonly List<string> _items = new List<string>();

    public void AddItem(string item)
    {
        _items.Add(item);
    }

    // Возвращает стандартный итератор List<T>
    public IEnumerator GetEnumerator()
    {
        return _items.GetEnumerator();
    }

    // Возвращает кастомный итератор (обратный порядок)
    public IEnumerable GetReverseEnumerator()
    {
        for (int i = _items.Count - 1; i >= 0; i--)
        {
            yield return _items[i];
        }
    }
}
var collection = new WordsCollection();
collection.AddItem("First");
collection.AddItem("Second");
collection.AddItem("Third");

// Стандартный перебор (IEnumerable)
foreach (var item in collection)
{
    Console.WriteLine(item); // First, Second, Third
}

// Кастомный итератор (обратный порядок)
foreach (var item in collection.GetReverseEnumerator())
{
    Console.WriteLine(item); // Third, Second, First
}


Тип: Поведенческий (Behavioral) паттерн проектирования.
Паттерн Iterator предоставляет способ последовательного доступа к элементам коллекции, не раскрывая её внутреннего представления. Он инкапсулирует логику обхода в отдельном объекте-итераторе.

Назначение:
Единообразный способ перебора разных структур данных (списки, деревья, графы и т. д.).
Сокрытие деталей реализации коллекции.
Поддержка нескольких вариантов обхода (например, прямой и обратный порядок).
Упрощение интерфейса коллекции (не засорять её методами обхода).

Метафоры из реального мира:
Путеводитель по музею – позволяет посетителям последовательно осматривать экспонаты, не зная, как организована их расстановка.
Пульт переключения каналов ТВ – даёт возможность перебирать каналы, не вникая в то, как они хранятся в телевизоре.
Курсор в базе данных – позволяет обрабатывать записи по одной, не загружая всю таблицу.

Потенциальные проблемы:
Избыточность – для простых коллекций (например, массивов) создание итератора может быть излишним.
Параллельный обход – если коллекция изменяется во время итерации, это может привести к ошибкам (ConcurrentModificationException в Java).
Производительность – в некоторых языках (например, C++) итераторы могут быть менее эффективны, чем прямой доступ.
Сложность реализации – для нелинейных структур (деревьев, графов) логика итератора может быть нетривиальной.
